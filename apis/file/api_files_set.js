// Generated by CoffeeScript 2.6.1
var Jimp, crypto, fileType, fs, options, pathLib, stream, uuid;

pathLib = require("path");

fs = require("fs-extra");

uuid = require("uuid").v4;

crypto = require("crypto");

fileType = require("file-type");

options = require("../../config/options");

Jimp = require("jimp");

stream = require("stream");

module.exports = {
  method: "post",
  path: "/api/files/set",
  options: {
    payload: {
      output: "stream",
      //uploads:pathLib.resolve "./www/data/avatars"
      parse: true,
      allow: ['multipart/form-data', "application/json"],
      multipart: true,
      maxBytes: 10 * 1024 * 1024 * 1024
    }
  },
  handler: async function(req, h) {
    var attachments_ImageThumbQuality, attachments_ImageThumbSize, attachments_size, attachments_uploadLimit, auth, bufferStream, data, db, err, extendName, file, fileName, filesTable, i, imageBuffer, index, j, jimp, len, len1, md5, newJimp, newReadStream, que, ref, ref1, ref2, sameFiles, sameFilesIndex, size, t, tableFile, type, userImgDir, writeFile;
    que = req.payload;
    db = req.server.db;
    auth = req.auth.credentials;
    userImgDir = pathLib.resolve("www/data/" + auth.userDir + "/files");
    filesTable = [];
    sameFilesIndex = [];
    writeFile = (path, file) => {
      return new Promise((res, rej) => {
        var writeStream;
        writeStream = new fs.createWriteStream(path);
        file.pipe(writeStream);
        writeStream.on("close", () => {
          return res();
        });
        return writeStream.on("error", (error) => {
          return rej(error);
        });
      });
    };
    if (!((ref = que.files) != null ? ref.length : void 0)) { //如果只有一个附件，转换成附件数组
      que.files = [que.files];
    }
    try {
      await fs.mkdirs(userImgDir); //确保目录存在
      t = (await db.mysql.transaction());
      //初步筛选类型
      attachments_size = (await options.get("attachments_size"));
      attachments_uploadLimit = (await options.get("attachments_uploadLimit"));
      attachments_ImageThumbSize = (await options.get("attachments_ImageThumbSize"));
      attachments_ImageThumbQuality = (await options.get("attachments_ImageThumbQuality"));
      if (auth.icat_users_extend.power >= 90) { //管理员允许大尺寸视频
        attachments_size.mp4 = 1024 * 1024;
        attachments_size.mov = 1024 * 1024;
      }
      if (que.files.length > attachments_uploadLimit) {
        await t.rollback();
        return {
          ok: false,
          msg: `超过单次附件上传个数限制（${attachments_uploadLimit}个）`
        };
      }
      ref1 = que.files;
      
      // 将文件先写入表
      for (index = i = 0, len = ref1.length; i < len; index = ++i) {
        file = ref1[index];
        //根据数据库设置检测类型和大小
        fileName = file.hapi.filename;
        extendName = (ref2 = fileName.match(/(?<=\.)\w+$/)) != null ? ref2[0] : void 0;
        if (!extendName) {
          await t.rollback();
          return {
            ok: false,
            msg: "文件丢失扩展名"
          };
        }
        if (!attachments_size[extendName]) {
          await t.rollback();
          return {
            ok: false,
            msg: `不支持的文件格式：${fileName};支持格式和尺寸如下（单位kb）：\n${JSON.stringify(attachments_size, null, "\t")}`
          };
        }
        if (file._data.length > attachments_size[extendName] * 1024) {
          await t.rollback();
          return {
            ok: false,
            msg: `文件尺寸超过限制：${fileName}；支持格式和尺寸如下（单位kb）：\n${JSON.stringify(attachments_size, null, "\t")}`
          };
        }
        //写入磁盘
        md5 = crypto.createHash("md5").update(file._data).digest("hex");
        //尺寸换算成kb-千字节
        size = file._data.byteLength / 1024;
        type = (await fileType.fromBuffer(file._data));
        fileName = uuid();
        
        //类型检测
        if (type === void 0) {
          await t.rollback();
          return {
            ok: false,
            msg: "含有无法识别的文件类型，或扩展名和文件实际类型不符"
          };
        }
        //根据md5检查文件是否已经被上传过
        sameFiles = (await db.icat_files.findAll({
          where: {
            md5: md5,
            isSystem: 0
          }
        }));
        if (sameFiles.length === 0) {
          data = (await db.icat_files.create({
            uid: auth.uid,
            user: auth.user,
            type: type.mime,
            size: size,
            isSystem: que.isSystem === "true" ? 1 : 0,
            directory: que.isSystem === "true" ? "statics/system" : `data/${auth.userDir}/files`,
            path: type.mime.match(/video/g) ? que.isSystem === "true" ? `statics/system/${fileName}.${extendName}` : `data/${auth.userDir}/files/${fileName}.${extendName}` : que.isSystem === "true" ? `statics/system/${fileName}.${type.ext}` : `data/${auth.userDir}/files/${fileName}.${type.ext}`,
            pathZip: type.mime.match(/video/g) ? que.isSystem === "true" ? `statics/system/${fileName}_min.${extendName}` : `data/${auth.userDir}/files/${fileName}_min.${extendName}` : que.isSystem === "true" ? `statics/system/${fileName}_min.${type.ext}` : `data/${auth.userDir}/files/${fileName}_min.${type.ext}`,
            md5: md5,
            name: fileName,
            extName: type.mime.match(/video/g) ? extendName : type.ext,
            defaultName: file.hapi.filename,
            timestamp: Date.now()
          }, {
            transaction: t
          }));
          filesTable.push(data);
        } else {
          sameFilesIndex.push(index);
          filesTable.push(sameFiles[0]);
        }
      }
      for (index = j = 0, len1 = filesTable.length; j < len1; index = ++j) {
        tableFile = filesTable[index];
        if (!sameFilesIndex.some((item) => {
          return item === index;
        })) {
          
            //准备压缩图片文件
          if (["image/jpeg", "image/png", "image/bmp", "image/tiff", "image/gif"].find((type) => {
            return type === tableFile.type;
          })) {
            jimp = (await Jimp.read(que.files[index]._data));
            newJimp = jimp.clone();
            if (typeof attachments_ImageThumbSize[0] === "number") {
              if (attachments_ImageThumbSize[1] === "auto") {
                if (newJimp.bitmap.width > attachments_ImageThumbSize[0]) {
                  await (function(rate, newHeight, newWidth) {
                    newWidth = attachments_ImageThumbSize[0];
                    rate = newJimp.bitmap.width / newWidth;
                    newHeight = newJimp.bitmap.height / rate;
                    return newJimp.resize(newWidth, newHeight);
                  })(null, null, null);
                }
              }
            } else if (attachments_ImageThumbSize[0] === "auto") {
              if (typeof attachments_ImageThumbSize[1] === "number") {
                if (newJimp.bitmap.height > attachments_ImageThumbSize[1]) {
                  await (function(rate, newHeight, newWidth) {
                    newHeight = attachments_ImageThumbSize[1];
                    rate = newJimp.bitmap.height / newHeight;
                    newWidth = newJimp.bitmap.width / rate;
                    return newJimp.resize(newWidth, newHeight);
                  })(null, null, null);
                }
              }
            }
            if (attachments_ImageThumbQuality > 0) {
              newJimp.quality(attachments_ImageThumbQuality);
            }
            imageBuffer = (await newJimp.getBufferAsync(tableFile.type));
            //buffer转换成写入流
            bufferStream = new stream.PassThrough();
            newReadStream = bufferStream.end(imageBuffer);
            await writeFile(pathLib.resolve(`www/${que.isSystem === "true" ? "public/" : ""}${tableFile.pathZip}`), newReadStream);
          }
          await writeFile(pathLib.resolve(`www/${que.isSystem === "true" ? "public/" : ""}${tableFile.path}`), que.files[index]);
        }
      }
      await t.commit();
      return {
        //这里有一个问题，如果有一个文件因为磁盘问题写入失败了，过程就会被中断，内容回滚
        //导致已经上传过的文件没有写入到数据库
        ok: true,
        msg: "上传成功",
        data: filesTable
      };
    } catch (error1) {
      err = error1;
      console.log(err);
      await t.rollback();
      return {
        ok: false,
        msg: "呜呜，服务器发生了一些错误"
      };
    }
  }
};
